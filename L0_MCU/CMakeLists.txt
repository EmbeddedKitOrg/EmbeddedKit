# ==========================================================
# 动态生成 weak_ek_main.c
# ==========================================================
# 定义生成文件的路径（放在 build 目录下，不污染源码）
set(GEN_WEAK_MAIN_SRC "${CMAKE_CURRENT_BINARY_DIR}/generated/weak_ek_main.c")

# 让 CMake 写入文件内容
file(WRITE ${GEN_WEAK_MAIN_SRC} 
"
/* This file is auto-generated by CMake */
/* Do not edit manually */

#include <stdint.h>

// 定义 weak 版本的 ek_main
__attribute__((weak)) void ek_main(void)
{
    // 可以在这里做一个死循环，或者闪烁 LED
    // 既然是自动生成的，简单死循环即可
    while(1)
    {
    }
}
")

# ==========================================================
# 定义 L0 库
# ==========================================================
add_library(l0_mcu STATIC
    ${GEN_WEAK_MAIN_SRC}
    # 将对应的问
)

target_link_libraries(l0_mcu PUBLIC
    global_macros
    global_options
)

target_include_directories(l0_mcu PUBLIC inc)

# ==============================================================================
# 加载具体 MCU 子模块 (关键步骤)
# ==============================================================================
# 设置默认 MCU 型号，允许命令行 -DMCU_MODEL=xxx 覆盖
set(MCU_MODEL "STM32F429VGT6" CACHE STRING "Select MCU Model")

message(STATUS "L0 Configuration: Integrating ${MCU_MODEL} into l0_mcu")

# 检查目录是否存在
if(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${MCU_MODEL}")
    message(FATAL_ERROR "MCU directory not found: ${CMAKE_CURRENT_SOURCE_DIR}/${MCU_MODEL}")
endif()

# 进入子目录。注意：此时 l0_mcu 目标已经存在，子目录可以向其添加文件
add_subdirectory(${MCU_MODEL})
