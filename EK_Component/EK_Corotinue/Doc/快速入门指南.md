# EmbeddedKit åç¨‹ç³»ç»Ÿå¿«é€Ÿå…¥é—¨æŒ‡å—

## ğŸš€ å¿«é€Ÿå¼€å§‹

æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨åœ¨5åˆ†é’Ÿå†…å¿«é€Ÿä¸Šæ‰‹ EmbeddedKit åç¨‹ç³»ç»Ÿï¼Œä»é›¶å¼€å§‹åˆ›å»ºæ‚¨çš„ç¬¬ä¸€ä¸ªå¤šä»»åŠ¡åº”ç”¨ã€‚

**é€‚ç”¨å¯¹è±¡**: æœ‰ä¸€å®šåµŒå…¥å¼å¼€å‘ç»éªŒçš„å¼€å‘è€…
**é¢„è®¡æ—¶é—´**: 5-10åˆ†é’Ÿ
**éš¾åº¦çº§åˆ«**: â­â­â˜†â˜†â˜†

---

## ğŸ“‹ å‡†å¤‡å·¥ä½œ

### å¼€å‘ç¯å¢ƒè¦æ±‚
- æ”¯æŒARM Cortex-Mçš„MCUï¼ˆå¦‚STM32F4ç³»åˆ—ï¼‰
- æ”¯æŒçš„ç¼–è¯‘å™¨ï¼šGCCã€ARMCCã€IARã€Clang
- HALåº“æˆ–CMSISåº“

### å¿…éœ€çš„æ–‡ä»¶
ç¡®ä¿æ‚¨çš„é¡¹ç›®åŒ…å«ä»¥ä¸‹æ–‡ä»¶ï¼š

```
YourProject/
â”œâ”€â”€ EK_Component/
â”‚   â”œâ”€â”€ EK_Common.h              // é€šç”¨å®šä¹‰
â”‚   â”œâ”€â”€ EK_Config.h              // ç³»ç»Ÿé…ç½®
â”‚   â”œâ”€â”€ MemPool/
â”‚   â”‚   â”œâ”€â”€ EK_MemPool.h
â”‚   â”‚   â””â”€â”€ EK_MemPool.c
â”‚   â”œâ”€â”€ DataStruct/
â”‚   â”‚   â””â”€â”€ Queue/
â”‚   â”‚       â”œâ”€â”€ EK_Queue.h
â”‚   â”‚       â””â”€â”€ EK_Queue.c
â”‚   â””â”€â”€ EK_Corotinue/
â”‚       â”œâ”€â”€ EK_CoroConfig.h      // åç¨‹é…ç½®
â”‚       â”œâ”€â”€ Kernel/
â”‚       â”‚   â”œâ”€â”€ Kernel.h
â”‚       â”‚   â””â”€â”€ Kernel.c
â”‚       â”œâ”€â”€ Task/
â”‚       â”‚   â”œâ”€â”€ EK_CoroTask.h
â”‚       â”‚   â””â”€â”€ EK_CoroTask.c
â”‚       â””â”€â”€ Message/
â”‚           â”œâ”€â”€ EK_CoroMessage.h
â”‚           â””â”€â”€ EK_CoroMessage.c
â””â”€â”€ main.c                       // æ‚¨çš„ä¸»ç¨‹åº
```

---

## âš¡ 5åˆ†é’Ÿå¿«é€Ÿä¸Šæ‰‹

### ç¬¬ä¸€æ­¥ï¼šé…ç½®ç³»ç»Ÿï¼ˆ1åˆ†é’Ÿï¼‰

#### 1.1 ä¿®æ”¹ `EK_CoroConfig.h`

```c
// å¿…é¡»åŒ…å«æ‚¨çš„MCUå¤´æ–‡ä»¶
#include "stm32f4xx_hal.h"  // â† æ ¹æ®æ‚¨çš„MCUä¿®æ”¹


```

#### 1.2 ä¿®æ”¹ `EK_Config.h`

```c
// ç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡
#define EK_CORO_SYSTEM_FREQ (SystemCoreClock)

// SysTickä¸­æ–­é¢‘ç‡ (1000Hz = 1msç²¾åº¦)
#define EK_CORO_TICK_RATE_HZ (1000)

// ä¼˜å…ˆçº§ç»„æ•°é‡
#define EK_CORO_PRIORITY_GROUPS (16)

// æ ˆæº¢å‡ºæ£€æµ‹ (0=ç¦ç”¨, 1=å¯ç”¨)
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// ç©ºé—²ä»»åŠ¡æ ˆå¤§å°
#define EK_CORO_IDLE_TASK_STACK_SIZE (256)

// æ¶ˆæ¯é˜Ÿåˆ—æ”¯æŒ
#define EK_CORO_MESSAGE_QUEUE_ENABLE (1)

// å¯ç”¨åç¨‹ç³»ç»Ÿ
#define EK_CORO_ENABLE (1)

// å†…å­˜æ± å¤§å° (10KB)
#define MEMPOOL_SIZE (10240)

// å†…å­˜å¯¹é½ (8å­—èŠ‚)
#define MEMPOOL_ALIGNMENT (8)
```

### ç¬¬äºŒæ­¥ï¼šé…ç½®ä¸­æ–­ï¼ˆ1åˆ†é’Ÿï¼‰

#### 2.1 åœ¨ `main.c` ä¸­æ·»åŠ ä¸­æ–­å¤„ç†

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"

// SysTickä¸­æ–­å¤„ç†
void SysTick_Handler(void) {
    // åç¨‹æ—¶é’Ÿå¤„ç†
    EK_vTickHandler();

    // å¦‚æœä½¿ç”¨HALåº“
    HAL_IncTick();
}

// PendSVä¸­æ–­å¤„ç†
void PendSV_Handler(void) {
    // åç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢
    EK_vPendSVHandler();
}
```

### ç¬¬ä¸‰æ­¥ï¼šåˆ›å»ºç¬¬ä¸€ä¸ªä»»åŠ¡ï¼ˆ2åˆ†é’Ÿï¼‰

#### 3.1 ç¼–å†™ä»»åŠ¡å‡½æ•°

```c
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"

// LEDé—ªçƒä»»åŠ¡
void LED_Task(void *arg) {
    // åˆå§‹åŒ–GPIO
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    while (1) {
        // LED ON
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
        EK_vCoroDelay(500);  // 500ms

        // LED OFF
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
        EK_vCoroDelay(500);  // 500ms
    }
}

// ä¸²å£æ‰“å°ä»»åŠ¡
void Print_Task(void *arg) {
    while (1) {
        printf("Hello from Coro Task!\r\n");
        EK_vCoroDelay(1000);  // 1ç§’æ‰“å°ä¸€æ¬¡
    }
}
```

#### 3.2 åœ¨ `main()` ä¸­åˆå§‹åŒ–ç³»ç»Ÿ

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/MemPool/EK_MemPool.h"

int main(void) {
    // HALåˆå§‹åŒ–
    HAL_Init();
    SystemClock_Config();

    // åˆå§‹åŒ–å†…å­˜æ± 
    EK_bMemPool_Init();

    // åˆå§‹åŒ–åç¨‹å†…æ ¸
    EK_vKernelInit();

    // åˆ›å»ºä»»åŠ¡
    EK_pCoroCreate(LED_Task, NULL, 1, 256);   // ä¼˜å…ˆçº§1ï¼Œæ ˆ256å­—èŠ‚
    EK_pCoroCreate(Print_Task, NULL, 2, 256); // ä¼˜å…ˆçº§2ï¼Œæ ˆ256å­—èŠ‚

    // å¯åŠ¨åç¨‹è°ƒåº¦å™¨
    EK_vKernelStart();

    // æ°¸è¿œä¸ä¼šåˆ°è¾¾è¿™é‡Œ
    while (1) {}
}
```

### ç¬¬å››æ­¥ï¼šç¼–è¯‘å’Œè¿è¡Œï¼ˆ1åˆ†é’Ÿï¼‰

#### 4.1 ç¼–è¯‘é¡¹ç›®
```bash
# GCCç¼–è¯‘ç¤ºä¾‹
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 \
    -I. -DHSE_VALUE=8000000 -std=gnu11 -Wall -Wextra \
    main.c EK_Component/MemPool/EK_MemPool.c \
    EK_Component/DataStruct/Queue/EK_Queue.c \
    EK_Component/EK_Corotinue/Kernel/Kernel.c \
    EK_Component/EK_Corotinue/Task/EK_CoroTask.c
```

#### 4.2 ä¸‹è½½å’Œè¿è¡Œ
å°†ç¨‹åºä¸‹è½½åˆ°æ‚¨çš„å¼€å‘æ¿ï¼Œæ‚¨åº”è¯¥çœ‹åˆ°ï¼š
- LEDæ¯ç§’é—ªçƒ2æ¬¡
- ä¸²å£æ¯ç§’æ‰“å°ä¸€æ¬¡æ¶ˆæ¯

---

## ğŸ¯ å®Œæ•´ç¤ºä¾‹ä»£ç 

### main.c å®Œæ•´ç¤ºä¾‹

```c
#include "stm32f4xx_hal.h"
#include <stdio.h>

// EmbeddedKit å¤´æ–‡ä»¶
#include "EK_Component/EK_Common.h"
#include "EK_Component/EK_Config.h"
#include "EK_Component/MemPool/EK_MemPool.h"
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"
#include "EK_Component/EK_Corotinue/Message/EK_CoroMessage.h"

// å¤–éƒ¨å£°æ˜ï¼ˆç”±HALæä¾›ï¼‰
extern void SystemClock_Config(void);

// ä»»åŠ¡å‡½æ•°å£°æ˜
void LED_Task(void *arg);
void Sensor_Task(void *arg);
void Monitor_Task(void *arg);

// å…¨å±€å˜é‡
EK_CoroMsgHanler_t sensor_queue;

// æ¶ˆæ¯ç»“æ„
typedef struct {
    float temperature;
    uint32_t timestamp;
} SensorData;

int main(void) {
    // HALåˆå§‹åŒ–
    HAL_Init();
    SystemClock_Config();

    // å†…å­˜æ± åˆå§‹åŒ–
    EK_bMemPool_Init();

    // åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—
    sensor_queue = EK_pMsgCreate(sizeof(SensorData), 5);

    // åç¨‹å†…æ ¸åˆå§‹åŒ–
    EK_vKernelInit();

    // åˆ›å»ºä»»åŠ¡
    EK_pCoroCreate(LED_Task, NULL, 1, 256);
    EK_pCoroCreate(Sensor_Task, NULL, 2, 512);
    EK_pCoroCreate(Monitor_Task, NULL, 3, 256);

    // å¯åŠ¨åç¨‹è°ƒåº¦å™¨
    EK_vKernelStart();

    while (1) {}
}

// LEDä»»åŠ¡
void LED_Task(void *arg) {
    // GPIOåˆå§‹åŒ–
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    while (1) {
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_0);
        EK_vCoroDelay(500);
    }
}

// ä¼ æ„Ÿå™¨ä»»åŠ¡
void Sensor_Task(void *arg) {
    SensorData data;
    uint32_t last_wake_time = EK_CoroKernelTick;

    while (1) {
        // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨è¯»å–
        data.temperature = 25.0f + (float)(rand() % 100) / 10.0f;
        data.timestamp = HAL_GetTick();

        // å‘é€æ•°æ®
        EK_rMsgSend(sensor_queue, &data, 100);

        // ç²¾ç¡®å»¶æ—¶1ç§’
        EK_vCoroDelayUntil(last_wake_time + 1000);
        last_wake_time += 1000;
    }
}

// ç›‘æ§ä»»åŠ¡
void Monitor_Task(void *arg) {
    SensorData data;

    while (1) {
        // æ¥æ”¶ä¼ æ„Ÿå™¨æ•°æ®
        if (EK_rMsgReceive(sensor_queue, &data, EK_MAX_DELAY) == EK_OK) {
            // å¤„ç†æ•°æ®
            printf("Temp: %.1fÂ°C, Time: %lu\r\n",
                   data.temperature, data.timestamp);

            // æ¸©åº¦è¿‡é«˜è­¦æŠ¥
            if (data.temperature > 30.0f) {
                HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET);
            } else {
                HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
            }
        }
    }
}

// ä¸­æ–­å¤„ç†
void SysTick_Handler(void) {
    EK_vTickHandler();
    HAL_IncTick();
}

void PendSV_Handler(void) {
    EK_vPendSVHandler();
}
```

---

## ğŸ”§ å¸¸ç”¨APIé€ŸæŸ¥

### ä»»åŠ¡ç®¡ç†
```c
// åˆ›å»ºä»»åŠ¡
EK_CoroHandler_t task = EK_pCoroCreate(TaskFunc, arg, priority, stack_size);

// åˆ é™¤ä»»åŠ¡
EK_vCoroDelete(task, &result);

// å»¶æ—¶
EK_vCoroDelay(100);  // 100ms

// ç²¾ç¡®å»¶æ—¶
EK_vCoroDelayUntil(wake_time);

// è®©å‡ºCPU
EK_vCoroYield();

// æŒ‚èµ·/æ¢å¤
EK_vCoroSuspend(task, &result);
EK_vCoroResume(task, &result);
```

### æ¶ˆæ¯é˜Ÿåˆ—
```c
// åˆ›å»ºé˜Ÿåˆ—
EK_CoroMsgHanler_t queue = EK_pMsgCreate(item_size, item_amount);

// å‘é€æ¶ˆæ¯
EK_rMsgSend(queue, &data, timeout);

// æ¥æ”¶æ¶ˆæ¯
EK_rMsgReceive(queue, &buffer, timeout);

// åˆ é™¤é˜Ÿåˆ—
EK_rMsgDelete(queue);
```

### å†…å­˜ç®¡ç†
```c
// åˆ†é…å†…å­˜
void *ptr = EK_CORO_MALLOC(size);

// é‡Šæ”¾å†…å­˜
EK_CORO_FREE(ptr);
```

---

## ğŸ” è°ƒè¯•æŠ€å·§

### 1. æ£€æŸ¥ä»»åŠ¡æ ˆä½¿ç”¨
```c
// åœ¨ä»»åŠ¡ä¸­å®šæœŸæ£€æŸ¥æ ˆä½¿ç”¨æƒ…å†µ
EK_Size_t water_mark = EK_uCoroGetHighWaterMark(EK_CoroKernelCurrentTCB);
if (water_mark < 32) {
    printf("Warning: Stack space low (%d bytes)\n", water_mark);
}
```

### 2. å†…å­˜æ± ç›‘æ§
```c
// ç›‘æ§å†…å­˜ä½¿ç”¨
PoolStats_t stats;
EK_vMemPool_GetStats(&stats);
printf("Memory: %d/%d bytes free\n",
       stats.Pool_FreeBytes, stats.Pool_TotalSize);
```

### 3. å¯ç”¨æ ˆæº¢å‡ºæ£€æµ‹
```c
// åœ¨EK_CoroConfig.hä¸­å¯ç”¨
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)
```

---

## âš ï¸ å¸¸è§é—®é¢˜

### Q1: ç¨‹åºå¯åŠ¨åå´©æºƒ
**A1**: æ£€æŸ¥ä»¥ä¸‹å†…å®¹ï¼š
- å†…å­˜æ± æ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
- SysTickå’ŒPendSVä¸­æ–­æ˜¯å¦æ­£ç¡®é…ç½®
- æ ˆå¤§å°æ˜¯å¦è¶³å¤Ÿ
- ä¼˜å…ˆçº§è®¾ç½®æ˜¯å¦æ­£ç¡®

### Q2: ä»»åŠ¡ä¸åˆ‡æ¢
**A2**: å¯èƒ½åŸå› ï¼š
- å¿˜è®°è°ƒç”¨ `EK_vKernelStart()`
- PendSVä¸­æ–­æœªè§¦å‘
- æ‰€æœ‰ä»»åŠ¡éƒ½å¤„äºé˜»å¡çŠ¶æ€

### Q3: å†…å­˜åˆ†é…å¤±è´¥
**A3**: è§£å†³æ–¹æ¡ˆï¼š
- å¢åŠ  `MEMPOOL_SIZE`
- æ£€æŸ¥å†…å­˜æ³„æ¼
- ä½¿ç”¨é™æ€åˆ†é…æ›¿ä»£åŠ¨æ€åˆ†é…

### Q4: æ¶ˆæ¯é˜Ÿåˆ—è¶…æ—¶
**A4**: ä¼˜åŒ–å»ºè®®ï¼š
- å¢åŠ é˜Ÿåˆ—å¤§å°
- è°ƒæ•´è¶…æ—¶æ—¶é—´
- ä¼˜åŒ–ä»»åŠ¡ä¼˜å…ˆçº§

---

## ğŸ“š è¿›é˜¶å­¦ä¹ 

å®Œæˆå¿«é€Ÿå…¥é—¨åï¼Œæ‚¨å¯ä»¥ï¼š

1. **é˜…è¯»å®Œæ•´æ–‡æ¡£**ï¼š
   - [ç§»æ¤æŒ‡å—](ç§»æ¤æŒ‡å—.md) - æ·±å…¥äº†è§£ç§»æ¤æ­¥éª¤
   - [APIå‚è€ƒæ‰‹å†Œ](APIå‚è€ƒæ‰‹å†Œ.md) - è¯¦ç»†APIè¯´æ˜

2. **å­¦ä¹ é«˜çº§ç‰¹æ€§**ï¼š
   - æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡
   - ä¼˜å…ˆçº§è°ƒåº¦
   - å†…å­˜ç®¡ç†ä¼˜åŒ–
   - æ ˆæº¢å‡ºæ£€æµ‹

3. **å®è·µé¡¹ç›®**ï¼š
   - å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†
   - é€šä¿¡åè®®æ ˆ
   - æ§åˆ¶ç³»ç»Ÿ
   - ç”¨æˆ·ç•Œé¢

---

## ğŸ‰ æ­å–œï¼

æ‚¨å·²ç»æˆåŠŸæŒæ¡äº† EmbeddedKit åç¨‹ç³»ç»Ÿçš„åŸºæœ¬ä½¿ç”¨æ–¹æ³•ã€‚é€šè¿‡æœ¬æŒ‡å—ï¼Œæ‚¨å­¦ä¼šäº†ï¼š

âœ… ç³»ç»Ÿé…ç½®å’Œç§»æ¤
âœ… åˆ›å»ºå’Œç®¡ç†ä»»åŠ¡
âœ… ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—
âœ… ä¸­æ–­å¤„ç†é…ç½®
âœ… åŸºæœ¬è°ƒè¯•æŠ€å·§

ç°åœ¨æ‚¨å¯ä»¥å¼€å§‹æ„å»ºæ›´å¤æ‚çš„å¤šä»»åŠ¡åµŒå…¥å¼åº”ç”¨äº†ï¼

**æŠ€æœ¯æ”¯æŒ**ï¼šå¦‚æœé‡åˆ°é—®é¢˜ï¼Œè¯·å‚è€ƒå®Œæ•´çš„[ç§»æ¤æŒ‡å—](ç§»æ¤æŒ‡å—.md)æˆ–[APIå‚è€ƒæ‰‹å†Œ](APIå‚è€ƒæ‰‹å†Œ.md)ã€‚

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-07