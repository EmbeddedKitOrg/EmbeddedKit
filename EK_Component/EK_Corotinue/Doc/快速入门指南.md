# EmbeddedKit 协程系统快速入门指南

## 🚀 快速开始

本指南将帮助您在5分钟内快速上手 EmbeddedKit 协程系统，从零开始创建您的第一个多任务应用。

**适用对象**: 有一定嵌入式开发经验的开发者
**预计时间**: 5-10分钟
**难度级别**: ⭐⭐☆☆☆

---

## 📋 准备工作

### 开发环境要求
- 支持ARM Cortex-M的MCU（如STM32F4系列）
- 支持的编译器：GCC、ARMCC、IAR、Clang
- HAL库或CMSIS库

### 必需的文件
确保您的项目包含以下文件：

```
YourProject/
├── EK_Component/
│   ├── EK_Common.h              // 通用定义
│   ├── EK_Config.h              // 系统配置
│   ├── MemPool/
│   │   ├── EK_MemPool.h
│   │   └── EK_MemPool.c
│   ├── DataStruct/
│   │   └── Queue/
│   │       ├── EK_Queue.h
│   │       └── EK_Queue.c
│   └── EK_Corotinue/
│       ├── EK_CoroConfig.h      // 协程配置
│       ├── Kernel/
│       │   ├── Kernel.h
│       │   └── Kernel.c
│       ├── Task/
│       │   ├── EK_CoroTask.h
│       │   └── EK_CoroTask.c
│       └── Message/
│           ├── EK_CoroMessage.h
│           └── EK_CoroMessage.c
└── main.c                       // 您的主程序
```

---

## ⚡ 5分钟快速上手

### 第一步：配置系统（1分钟）

#### 1.1 修改 `EK_CoroConfig.h`

```c
// 必须包含您的MCU头文件
#include "stm32f4xx_hal.h"  // ← 根据您的MCU修改


```

#### 1.2 修改 `EK_Config.h`

```c
// 系统时钟频率
#define EK_CORO_SYSTEM_FREQ (SystemCoreClock)

// SysTick中断频率 (1000Hz = 1ms精度)
#define EK_CORO_TICK_RATE_HZ (1000)

// 优先级组数量
#define EK_CORO_PRIORITY_GROUPS (16)

// 栈溢出检测 (0=禁用, 1=启用)
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// 空闲任务栈大小
#define EK_CORO_IDLE_TASK_STACK_SIZE (256)

// 消息队列支持
#define EK_CORO_MESSAGE_QUEUE_ENABLE (1)

// 启用协程系统
#define EK_CORO_ENABLE (1)

// 内存池大小 (10KB)
#define MEMPOOL_SIZE (10240)

// 内存对齐 (8字节)
#define MEMPOOL_ALIGNMENT (8)
```

### 第二步：配置中断（1分钟）

#### 2.1 在 `main.c` 中添加中断处理

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"

// SysTick中断处理
void SysTick_Handler(void) {
    // 协程时钟处理
    EK_vTickHandler();

    // 如果使用HAL库
    HAL_IncTick();
}

// PendSV中断处理
void PendSV_Handler(void) {
    // 协程上下文切换
    EK_vPendSVHandler();
}
```

### 第三步：创建第一个任务（2分钟）

#### 3.1 编写任务函数

```c
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"

// LED闪烁任务
void LED_Task(void *arg) {
    // 初始化GPIO
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    while (1) {
        // LED ON
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
        EK_vCoroDelay(500);  // 500ms

        // LED OFF
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
        EK_vCoroDelay(500);  // 500ms
    }
}

// 串口打印任务
void Print_Task(void *arg) {
    while (1) {
        printf("Hello from Coro Task!\r\n");
        EK_vCoroDelay(1000);  // 1秒打印一次
    }
}
```

#### 3.2 在 `main()` 中初始化系统

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/MemPool/EK_MemPool.h"

int main(void) {
    // HAL初始化
    HAL_Init();
    SystemClock_Config();

    // 初始化内存池
    EK_bMemPool_Init();

    // 初始化协程内核
    EK_vKernelInit();

    // 创建任务
    EK_pCoroCreate(LED_Task, NULL, 1, 256);   // 优先级1，栈256字节
    EK_pCoroCreate(Print_Task, NULL, 2, 256); // 优先级2，栈256字节

    // 启动协程调度器
    EK_vKernelStart();

    // 永远不会到达这里
    while (1) {}
}
```

### 第四步：编译和运行（1分钟）

#### 4.1 编译项目
```bash
# GCC编译示例
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 \
    -I. -DHSE_VALUE=8000000 -std=gnu11 -Wall -Wextra \
    main.c EK_Component/MemPool/EK_MemPool.c \
    EK_Component/DataStruct/Queue/EK_Queue.c \
    EK_Component/EK_Corotinue/Kernel/Kernel.c \
    EK_Component/EK_Corotinue/Task/EK_CoroTask.c
```

#### 4.2 下载和运行
将程序下载到您的开发板，您应该看到：
- LED每秒闪烁2次
- 串口每秒打印一次消息

---

## 🎯 完整示例代码

### main.c 完整示例

```c
#include "stm32f4xx_hal.h"
#include <stdio.h>

// EmbeddedKit 头文件
#include "EK_Component/EK_Common.h"
#include "EK_Component/EK_Config.h"
#include "EK_Component/MemPool/EK_MemPool.h"
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"
#include "EK_Component/EK_Corotinue/Message/EK_CoroMessage.h"

// 外部声明（由HAL提供）
extern void SystemClock_Config(void);

// 任务函数声明
void LED_Task(void *arg);
void Sensor_Task(void *arg);
void Monitor_Task(void *arg);

// 全局变量
EK_CoroMsgHanler_t sensor_queue;

// 消息结构
typedef struct {
    float temperature;
    uint32_t timestamp;
} SensorData;

int main(void) {
    // HAL初始化
    HAL_Init();
    SystemClock_Config();

    // 内存池初始化
    EK_bMemPool_Init();

    // 创建消息队列
    sensor_queue = EK_pMsgCreate(sizeof(SensorData), 5);

    // 协程内核初始化
    EK_vKernelInit();

    // 创建任务
    EK_pCoroCreate(LED_Task, NULL, 1, 256);
    EK_pCoroCreate(Sensor_Task, NULL, 2, 512);
    EK_pCoroCreate(Monitor_Task, NULL, 3, 256);

    // 启动协程调度器
    EK_vKernelStart();

    while (1) {}
}

// LED任务
void LED_Task(void *arg) {
    // GPIO初始化
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    while (1) {
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_0);
        EK_vCoroDelay(500);
    }
}

// 传感器任务
void Sensor_Task(void *arg) {
    SensorData data;
    uint32_t last_wake_time = EK_CoroKernelTick;

    while (1) {
        // 模拟传感器读取
        data.temperature = 25.0f + (float)(rand() % 100) / 10.0f;
        data.timestamp = HAL_GetTick();

        // 发送数据
        EK_rMsgSend(sensor_queue, &data, 100);

        // 精确延时1秒
        EK_vCoroDelayUntil(last_wake_time + 1000);
        last_wake_time += 1000;
    }
}

// 监控任务
void Monitor_Task(void *arg) {
    SensorData data;

    while (1) {
        // 接收传感器数据
        if (EK_rMsgReceive(sensor_queue, &data, EK_MAX_DELAY) == EK_OK) {
            // 处理数据
            printf("Temp: %.1f°C, Time: %lu\r\n",
                   data.temperature, data.timestamp);

            // 温度过高警报
            if (data.temperature > 30.0f) {
                HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET);
            } else {
                HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
            }
        }
    }
}

// 中断处理
void SysTick_Handler(void) {
    EK_vTickHandler();
    HAL_IncTick();
}

void PendSV_Handler(void) {
    EK_vPendSVHandler();
}
```

---

## 🔧 常用API速查

### 任务管理
```c
// 创建任务
EK_CoroHandler_t task = EK_pCoroCreate(TaskFunc, arg, priority, stack_size);

// 删除任务
EK_vCoroDelete(task, &result);

// 延时
EK_vCoroDelay(100);  // 100ms

// 精确延时
EK_vCoroDelayUntil(wake_time);

// 让出CPU
EK_vCoroYield();

// 挂起/恢复
EK_vCoroSuspend(task, &result);
EK_vCoroResume(task, &result);
```

### 消息队列
```c
// 创建队列
EK_CoroMsgHanler_t queue = EK_pMsgCreate(item_size, item_amount);

// 发送消息
EK_rMsgSend(queue, &data, timeout);

// 接收消息
EK_rMsgReceive(queue, &buffer, timeout);

// 删除队列
EK_rMsgDelete(queue);
```

### 内存管理
```c
// 分配内存
void *ptr = EK_CORO_MALLOC(size);

// 释放内存
EK_CORO_FREE(ptr);
```

---

## 🔍 调试技巧

### 1. 检查任务栈使用
```c
// 在任务中定期检查栈使用情况
EK_Size_t water_mark = EK_uCoroGetHighWaterMark(EK_CoroKernelCurrentTCB);
if (water_mark < 32) {
    printf("Warning: Stack space low (%d bytes)\n", water_mark);
}
```

### 2. 内存池监控
```c
// 监控内存使用
PoolStats_t stats;
EK_vMemPool_GetStats(&stats);
printf("Memory: %d/%d bytes free\n",
       stats.Pool_FreeBytes, stats.Pool_TotalSize);
```

### 3. 启用栈溢出检测
```c
// 在EK_CoroConfig.h中启用
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)
```

---

## ⚠️ 常见问题

### Q1: 程序启动后崩溃
**A1**: 检查以下内容：
- 内存池是否正确初始化
- SysTick和PendSV中断是否正确配置
- 栈大小是否足够
- 优先级设置是否正确

### Q2: 任务不切换
**A2**: 可能原因：
- 忘记调用 `EK_vKernelStart()`
- PendSV中断未触发
- 所有任务都处于阻塞状态

### Q3: 内存分配失败
**A3**: 解决方案：
- 增加 `MEMPOOL_SIZE`
- 检查内存泄漏
- 使用静态分配替代动态分配

### Q4: 消息队列超时
**A4**: 优化建议：
- 增加队列大小
- 调整超时时间
- 优化任务优先级

---

## 📚 进阶学习

完成快速入门后，您可以：

1. **阅读完整文档**：
   - [移植指南](移植指南.md) - 深入了解移植步骤
   - [API参考手册](API参考手册.md) - 详细API说明

2. **学习高级特性**：
   - 消息队列通信
   - 优先级调度
   - 内存管理优化
   - 栈溢出检测

3. **实践项目**：
   - 多传感器数据采集
   - 通信协议栈
   - 控制系统
   - 用户界面

---

## 🎉 恭喜！

您已经成功掌握了 EmbeddedKit 协程系统的基本使用方法。通过本指南，您学会了：

✅ 系统配置和移植
✅ 创建和管理任务
✅ 使用消息队列
✅ 中断处理配置
✅ 基本调试技巧

现在您可以开始构建更复杂的多任务嵌入式应用了！

**技术支持**：如果遇到问题，请参考完整的[移植指南](移植指南.md)或[API参考手册](API参考手册.md)。

**版本**: v1.0
**更新日期**: 2025-10-07