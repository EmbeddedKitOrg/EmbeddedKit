# EmbeddedKit åç¨‹ç³»ç»Ÿç§»æ¤æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

EmbeddedKit åç¨‹ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸“ä¸º ARM Cortex-M å¾®æ§åˆ¶å™¨è®¾è®¡çš„è½»é‡çº§åä½œå¼å¤šä»»åŠ¡ç³»ç»Ÿã€‚æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†å¦‚ä½•å°†åç¨‹ç³»ç»Ÿç§»æ¤åˆ°æ‚¨çš„ç›®æ ‡å¹³å°ï¼ŒåŒ…æ‹¬é…ç½®ã€API ä½¿ç”¨å’Œæœ€ä½³å®è·µã€‚

**ç‰ˆæœ¬**: 1.0
**ä½œè€…**: N1ntyNine99
**æ›´æ–°æ—¥æœŸ**: 2025-10-07

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

```
EK_Corotinue/
â”œâ”€â”€ Kernel/          # åç¨‹å†…æ ¸æ ¸å¿ƒ
â”‚   â”œâ”€â”€ Kernel.h     # å†…æ ¸æ•°æ®ç»“æ„å’ŒAPIå®šä¹‰
â”‚   â”œâ”€â”€ Kernel.c     # å†…æ ¸å®ç°
â”‚   â””â”€â”€ Heap.c       # åç¨‹ä¸“ç”¨å †ç®¡ç†
â”œâ”€â”€ Task/            # ä»»åŠ¡ç®¡ç†
â”‚   â”œâ”€â”€ EK_CoroTask.h # ä»»åŠ¡æ“ä½œAPI
â”‚   â””â”€â”€ EK_CoroTask.c # ä»»åŠ¡å®ç°
â”œâ”€â”€ Message/         # æ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”œâ”€â”€ EK_CoroMessage.h # æ¶ˆæ¯é˜Ÿåˆ—API
â”‚   â””â”€â”€ EK_CoroMessage.c # æ¶ˆæ¯é˜Ÿåˆ—å®ç°
â”œâ”€â”€ EK_CoroConfig.h  # åç¨‹åº•å±‚é…ç½®
â””â”€â”€ Doc/             # æ–‡æ¡£ç›®å½•
    â””â”€â”€ ç§»æ¤æŒ‡å—.md  # æœ¬æ–‡æ¡£
```

### ç³»ç»Ÿä¾èµ–å…³ç³»

```
åç¨‹ç³»ç»Ÿ
    â†“
å†…å­˜æ± ç³»ç»Ÿ (MemPool/)
    â†“
æ•°æ®ç»“æ„ (DataStruct/)
    â†“
é€šç”¨å®šä¹‰ (EK_Common.h)
    â†“
ç³»ç»Ÿé…ç½® (EK_Config.h)
```

---

## ğŸš€ ç§»æ¤æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šå‡†å¤‡åŸºç¡€ç¯å¢ƒ

#### 1.1 åŒ…å«å¿…è¦çš„æ–‡ä»¶

ç¡®ä¿æ‚¨çš„é¡¹ç›®ä¸­åŒ…å«ä»¥ä¸‹æ¨¡å—ï¼š

```c
// å¿…é¡»åŒ…å«çš„æ ¸å¿ƒæ–‡ä»¶
#include "EK_Component/EK_Common.h"          // é€šç”¨å®šä¹‰å’Œç±»å‹
#include "EK_Component/EK_Config.h"         // ç³»ç»Ÿé…ç½®
#include "EK_Component/MemPool/EK_MemPool.h" // å†…å­˜æ± ç®¡ç†
#include "EK_Component/DataStruct/Queue/EK_Queue.h" // é˜Ÿåˆ—æ•°æ®ç»“æ„ åªæœ‰è¦ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—æ‰ä½¿ç”¨
```

#### 1.2 åˆå§‹åŒ–å†…å­˜æ± 

åç¨‹ç³»ç»Ÿä¾èµ–å†…å­˜æ± è¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ï¼š

```c
#include "EK_Component/MemPool/EK_MemPool.h"

// åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶è°ƒç”¨
void System_Init(void) {
    // åˆå§‹åŒ–å†…å­˜æ± 
    EK_bMemPool_Init();

    // å…¶ä»–åˆå§‹åŒ–...
}
```

### ç¬¬äºŒæ­¥ï¼šé…ç½®åç¨‹ç³»ç»Ÿ

#### 2.1 ä¿®æ”¹ EK_CoroConfig.h

`EK_CoroConfig.h` æ˜¯åç¨‹ç³»ç»Ÿçš„åº•å±‚é…ç½®æ–‡ä»¶ï¼Œéœ€è¦æ ¹æ®æ‚¨çš„ç¡¬ä»¶ç¯å¢ƒè¿›è¡Œé…ç½®ï¼š

```c
/**
 * @warning: æ­¤å¤„å¿…é¡»è¦åŒ…å«ä½ çš„è®¾å¤‡çš„æ–‡ä»¶å¤´ï¼
 * @example: #include "stm32f4xx_hal.h"
 */
#include "stm32f4xx_hal.h"  // â† æ ¹æ®æ‚¨çš„MCUä¿®æ”¹

// ç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡
#define EK_CORO_SYSTEM_FREQ (SystemCoreClock)

// SysTickä¸­æ–­é¢‘ç‡ (Hz)
#define EK_CORO_TICK_RATE_HZ (1000)

// ä¼˜å…ˆçº§ç»„æ•°é‡ (8, 16, æˆ– 32)
#define EK_CORO_PRIORITY_GROUPS (16)

// æ ˆæº¢å‡ºæ£€æµ‹: 0=ç¦ç”¨, 1=æ–¹æ³•1, 2=æ–¹æ³•2
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// ç©ºé—²ä»»åŠ¡æ ˆå¤§å° (æ ¹æ®FPUä½¿ç”¨æƒ…å†µè°ƒæ•´)
#define EK_CORO_IDLE_TASK_STACK_SIZE (256)

// æ¶ˆæ¯é˜Ÿåˆ—æ”¯æŒ
#define EK_CORO_MESSAGE_QUEUE_ENABLE (1)
```

#### 2.2 åœ¨ EK_Config.h ä¸­å¯ç”¨åç¨‹

`EK_Config.h` æ˜¯ä¸»é…ç½®æ–‡ä»¶ï¼Œæ§åˆ¶åç¨‹ç³»ç»Ÿçš„å¯ç”¨å’Œå…¨å±€å‚æ•°ï¼š

```c
// å¯ç”¨åç¨‹ç³»ç»Ÿ
#define EK_CORO_ENABLE (1)

// ç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡
#define EK_CORO_SYSTEM_FREQ (SystemCoreClock)

// SysTickä¸­æ–­é¢‘ç‡
#define EK_CORO_TICK_RATE_HZ (1000)

// ä¼˜å…ˆçº§ç»„æ•°ç›®
#define EK_CORO_PRIORITY_GROUPS (16)

// åç¨‹ç©ºé—²ä»»åŠ¡æ ˆå¤§å°
#define EK_CORO_IDLE_TASK_STACK_SIZE (256)

// æ¶ˆæ¯é˜Ÿåˆ—æ”¯æŒ
#define EK_CORO_MESSAGE_QUEUE_ENABLE (1)

// æ ˆæº¢å‡ºæ£€æµ‹æ–¹æ³•
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (0)  // 0:ç¦ç”¨ 1:æ–¹æ³•1 2:æ–¹æ³•2
```

### ç¬¬ä¸‰æ­¥ï¼šé…ç½®ä¸­æ–­å¤„ç†

#### 3.1 é…ç½® SysTick ä¸­æ–­

åœ¨æ‚¨çš„ SysTick ä¸­æ–­å¤„ç†å‡½æ•°ä¸­æ·»åŠ åç¨‹çš„æ—¶é’Ÿå¤„ç†ï¼š

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"

void SysTick_Handler(void) {
    // è°ƒç”¨åç¨‹çš„æ—¶é’Ÿå¤„ç†å‡½æ•°
    EK_vTickHandler();

    // å¦‚æœæœ‰HALåº“ï¼Œè¿˜éœ€è¦è°ƒç”¨HALçš„SysTickå¤„ç†
    // HAL_IncTick();
    // HAL_SYSTICK_IRQHandler();
}
```

> [!NOTE]
>
> å¦‚æœæ‚¨æ˜¯ä½¿ç”¨çš„æ˜¯STM32çš„HALåº“ï¼Œå»ºè®®è®©HALåº“çš„uwTickçš„ç›¸å…³ç§»åŠ¨åˆ°å…¶ä»–å®šæ—¶å™¨ï¼Œåœ¨CubeMXä¸­é…ç½®å³å¯

#### 3.2 é…ç½® PendSV ä¸­æ–­

PendSV ä¸­æ–­ç”¨äºåç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œéœ€è¦åœ¨ä¸­æ–­å‘é‡è¡¨ä¸­é…ç½®ï¼š

```c
// åœ¨ä¸­æ–­å‘é‡è¡¨ä¸­æ·»åŠ  PendSV_Handler
void PendSV_Handler(void) {
    // è°ƒç”¨åç¨‹çš„PendSVå¤„ç†å®
    EK_vPendSVHandler();
}
```

#### 3.3 ä¸­æ–­ä¼˜å…ˆçº§é…ç½®

ç¡®ä¿ PendSV å’Œ SysTick çš„ä¼˜å…ˆçº§è®¾ç½®æ­£ç¡®ï¼š

```c
// è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§
void NVIC_Configuration(void) {
    // PendSV åº”è¯¥è®¾ç½®ä¸ºæœ€ä½ä¼˜å…ˆçº§
    NVIC_SetPriority(PendSV_IRQn, 0xFF);

    // SysTick ä¼˜å…ˆçº§åº”è¯¥é«˜äº PendSV
    NVIC_SetPriority(SysTick_IRQn, 0xF0);
}
```

### ç¬¬å››æ­¥ï¼šå¯åŠ¨åç¨‹ç³»ç»Ÿ

#### 4.1 åˆå§‹åŒ–åç¨‹å†…æ ¸

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"

int main(void) {
    // ç¡¬ä»¶åˆå§‹åŒ–
    HAL_Init();
    SystemClock_Config();

    // åˆå§‹åŒ–åç¨‹å†…æ ¸
    EK_vKernelInit(); // å…¶ä¸­ä¼šè‡ªåŠ¨åˆå§‹åŒ–å†…å­˜æ± 

    // åˆ›å»ºåç¨‹ä»»åŠ¡
    EK_pCoroCreate(Task1, NULL, 1, 256);
    EK_pCoroCreate(Task2, NULL, 2, 256);

    // å¯åŠ¨åç¨‹è°ƒåº¦å™¨
    EK_vKernelStart();

    // æ°¸è¿œä¸ä¼šåˆ°è¾¾è¿™é‡Œ
    while (1) {}
}
```

#### 4.2 ç¤ºä¾‹ä»»åŠ¡å‡½æ•°

```c
// ä»»åŠ¡1ç¤ºä¾‹
void Task1(void *arg) {
    while (1) {
        // ä»»åŠ¡ä»£ç 
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_0);

        // å»¶æ—¶ 500ms
        EK_vCoroDelay(500);
    }
}

// ä»»åŠ¡2ç¤ºä¾‹
void Task2(void *arg) {
    while (1) {
        // ä»»åŠ¡ä»£ç 
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1);

        // å»¶æ—¶ 1000ms
        EK_vCoroDelay(1000);
    }
}
```

---

## âš™ï¸ é…ç½®å‚æ•°è¯¦è§£

### ç³»ç»Ÿé…ç½®å‚æ•°

#### EK_CORO_ENABLE
- **ç±»å‹**: `0` æˆ– `1`
- **é»˜è®¤å€¼**: `1`
- **ä½œç”¨**: å¯ç”¨æˆ–ç¦ç”¨åç¨‹ç³»ç»Ÿ
- **è¯´æ˜**: è®¾ä¸º `0` æ—¶ä¼šä½¿ç”¨æ™®é€šçš„ä»»åŠ¡è°ƒåº¦å™¨

#### EK_CORO_SYSTEM_FREQ
- **ç±»å‹**: `uint32_t`
- **é»˜è®¤å€¼**: `SystemCoreClock`
- **ä½œç”¨**: ç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡
- **è¯´æ˜**: ç”¨äºè®¡ç®— SysTick é‡è½½å€¼

#### EK_CORO_TICK_RATE_HZ
- **ç±»å‹**: `uint32_t`
- **é»˜è®¤å€¼**: `1000`
- **ä½œç”¨**: SysTick ä¸­æ–­é¢‘ç‡
- **è¯´æ˜**: å†³å®šç³»ç»Ÿæ—¶é—´ç²¾åº¦ï¼Œå€¼è¶Šå¤§ç²¾åº¦è¶Šé«˜ä½†å¼€é”€è¶Šå¤§

#### EK_CORO_PRIORITY_GROUPS
- **ç±»å‹**: `8`, `16`, æˆ– `32`
- **é»˜è®¤å€¼**: `16`
- **ä½œç”¨**: ä¼˜å…ˆçº§ç»„æ•°é‡
- **è¯´æ˜**:
  - `8`: ä½¿ç”¨ uint8_t ä½å›¾ï¼Œ8ä¸ªä¼˜å…ˆçº§
  - `16`: ä½¿ç”¨ uint16_t ä½å›¾ï¼Œ16ä¸ªä¼˜å…ˆçº§
  - `32`: ä½¿ç”¨ uint32_t ä½å›¾ï¼Œ32ä¸ªä¼˜å…ˆçº§

#### EK_CORO_IDLE_TASK_STACK_SIZE
- **ç±»å‹**: `EK_Size_t`
- **é»˜è®¤å€¼**: `256` (æ— FPU) / `512` (æœ‰FPU)
- **ä½œç”¨**: ç©ºé—²ä»»åŠ¡çš„æ ˆå¤§å°
- **è¯´æ˜**: æ ¹æ®æ˜¯å¦ä½¿ç”¨ FPU è‡ªåŠ¨è°ƒæ•´

#### EK_CORO_MESSAGE_QUEUE_ENABLE
- **ç±»å‹**: `0` æˆ– `1`
- **é»˜è®¤å€¼**: `1`
- **ä½œç”¨**: å¯ç”¨æˆ–ç¦ç”¨æ¶ˆæ¯é˜Ÿåˆ—åŠŸèƒ½
- **è¯´æ˜**: ç¦ç”¨å¯å‡å°‘ä»£ç å¤§å°å’Œå†…å­˜ä½¿ç”¨

#### EK_CORO_STACK_OVERFLOW_CHECK_ENABLE
- **ç±»å‹**: `0`, `1`, æˆ– `2`
- **é»˜è®¤å€¼**: `0`
- **ä½œç”¨**: æ ˆæº¢å‡ºæ£€æµ‹æ–¹æ³•
- **è¯´æ˜**:
  - `0`: ç¦ç”¨æ ˆæº¢å‡ºæ£€æµ‹
  - `1`: æ–¹æ³•1ï¼ˆæ£€æµ‹æ ˆåº•å¡«å……å€¼ï¼‰
  - `2`: æ–¹æ³•2ï¼ˆæ£€æµ‹æ ˆæŒ‡é’ˆèŒƒå›´ï¼‰

### å†…å­˜æ± é…ç½®

#### MEMPOOL_SIZE
- **ç±»å‹**: `EK_Size_t`
- **é»˜è®¤å€¼**: `10240` (10KB)
- **ä½œç”¨**: å†…å­˜æ± æ€»å¤§å°
- **è¯´æ˜**: æ ¹æ®ç³»ç»Ÿå†…å­˜èµ„æºè°ƒæ•´

#### MEMPOOL_ALIGNMENT
- **ç±»å‹**: `EK_Size_t`
- **é»˜è®¤å€¼**: `8`
- **ä½œç”¨**: å†…å­˜å¯¹é½å¤§å°
- **è¯´æ˜**: å¿…é¡»æ˜¯2çš„å¹‚æ¬¡ï¼Œé€šå¸¸ä¸º4æˆ–8å­—èŠ‚

---

## ğŸ“š API ä½¿ç”¨æŒ‡å—

### ä»»åŠ¡ç®¡ç† API

#### åˆ›å»ºä»»åŠ¡

```c
// åŠ¨æ€åˆ›å»ºä»»åŠ¡
EK_CoroHandler_t task1 = EK_pCoroCreate(
    TaskFunction,    // ä»»åŠ¡å‡½æ•°
    arg,             // ä»»åŠ¡å‚æ•°
    priority,        // ä¼˜å…ˆçº§ (æ•°å€¼è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜)
    stack_size       // æ ˆå¤§å°
);

// é™æ€åˆ›å»ºä»»åŠ¡
EK_CoroTCB_t tcb;
uint32_t stack[256];
EK_CoroStaticHandler_t task2 = EK_pCoroCreateStatic(
    &tcb,            // é™æ€TCB
    TaskFunction,    // ä»»åŠ¡å‡½æ•°
    arg,             // ä»»åŠ¡å‚æ•°
    priority,        // ä¼˜å…ˆçº§
    stack,           // é™æ€æ ˆ
    sizeof(stack)    // æ ˆå¤§å°
);
```

#### ä»»åŠ¡æ§åˆ¶

```c
// æŒ‚èµ·ä»»åŠ¡
EK_vCoroSuspend(task_handle, &result);

// æ¢å¤ä»»åŠ¡
EK_vCoroResume(task_handle, &result);

// åˆ é™¤ä»»åŠ¡
EK_vCoroDelete(task_handle, &result);

// ä¸»åŠ¨è®©å‡ºCPU
EK_vCoroYield();
```

#### å»¶æ—¶æ“ä½œ

```c
// ç›¸å¯¹å»¶æ—¶
EK_vCoroDelay(100);  // å»¶æ—¶100ä¸ªtick

// ç»å¯¹å»¶æ—¶
EK_vCoroDelayUntil(wake_time);  // å»¶æ—¶åˆ°æŒ‡å®šæ—¶é—´ç‚¹

// å”¤é†’ä»»åŠ¡
EK_rCoroWakeup(task_handle);
```

#### ä»»åŠ¡ä¿¡æ¯æŸ¥è¯¢

```c
// è·å–ä»»åŠ¡æ ˆå¤§å°
EK_Size_t stack_size = EK_uCoroGetStack(task_handle);

// è·å–ä»»åŠ¡æ ˆé«˜æ°´ä½æ ‡è®°
EK_Size_t high_water = EK_uCoroGetHighWaterMark(task_handle);

// è®¾ç½®ä»»åŠ¡ä¼˜å…ˆçº§
EK_vCoroSetPriority(task_handle, new_priority, &result);
```

### æ¶ˆæ¯é˜Ÿåˆ— API

#### åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—

```c
// åŠ¨æ€åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—
EK_CoroMsgHanler_t msg_queue = EK_pMsgCreate(
    item_size,      // æ¯ä¸ªæ¶ˆæ¯çš„å¤§å°
    item_amount     // æ¶ˆæ¯æ•°é‡
);

// é™æ€åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—
EK_CoroMsg_t msg_struct;
uint8_t msg_buffer[10 * sizeof(MyMessage)];
EK_CoroMsgStaticHanler_t static_queue = EK_pMsgCreateStatic(
    &msg_struct,    // é™æ€æ¶ˆæ¯é˜Ÿåˆ—ç»“æ„
    msg_buffer,     // æ¶ˆæ¯ç¼“å†²åŒº
    sizeof(MyMessage), // æ¶ˆæ¯å¤§å°
    10              // æ¶ˆæ¯æ•°é‡
);
```

#### æ¶ˆæ¯å‘é€å’Œæ¥æ”¶

```c
// å‘é€æ¶ˆæ¯ (é˜»å¡)
EK_Result_t result = EK_rMsgSend(
    msg_queue,      // æ¶ˆæ¯é˜Ÿåˆ—å¥æŸ„
    &my_message,    // è¦å‘é€çš„æ¶ˆæ¯
    timeout         // è¶…æ—¶æ—¶é—´
);

// æ¥æ”¶æ¶ˆæ¯ (é˜»å¡)
EK_Result_t result = EK_rMsgReceive(
    msg_queue,      // æ¶ˆæ¯é˜Ÿåˆ—å¥æŸ„
    &received_msg,  // æ¥æ”¶ç¼“å†²åŒº
    timeout         // è¶…æ—¶æ—¶é—´
);
```

#### æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†

```c
// åˆ é™¤æ¶ˆæ¯é˜Ÿåˆ—
EK_Result_t result = EK_rMsgDelete(msg_queue);
```

---

## ğŸ”§ æœ€ä½³å®è·µ

### 1. ä»»åŠ¡è®¾è®¡åŸåˆ™

#### ä»»åŠ¡ä¼˜å…ˆçº§åˆ†é…
- æ•°å€¼è¶Šå°ï¼Œä¼˜å…ˆçº§è¶Šé«˜
- å»ºè®®å°†å…³é”®ä»»åŠ¡è®¾ç½®ä¸ºé«˜ä¼˜å…ˆçº§
- é¿å…è¿‡å¤šä»»åŠ¡ä½¿ç”¨ç›¸åŒä¼˜å…ˆçº§

#### æ ˆå¤§å°é…ç½®
```c
// æ ¹æ®ä»»åŠ¡å¤æ‚åº¦é…ç½®æ ˆå¤§å°
#define TASK_STACK_MIN    128   // ç®€å•ä»»åŠ¡
#define TASK_STACK_MID    256   // ä¸­ç­‰å¤æ‚åº¦ä»»åŠ¡
#define TASK_STACK_MAX    512   // å¤æ‚ä»»åŠ¡
#define TASK_STACK_FPU    1024  // ä½¿ç”¨FPUçš„å¤æ‚ä»»åŠ¡
```

#### ä»»åŠ¡å‡½æ•°ç»“æ„
```c
void TaskFunction(void *arg) {
    // ä»»åŠ¡åˆå§‹åŒ–ä»£ç 
    Task_Init();

    while (1) {
        // ä»»åŠ¡ä¸»å¾ªç¯
        Task_Process();

        // é€‚å½“çš„å»¶æ—¶æˆ–è®©å‡ºCPU
        EK_vCoroDelay(10);
    }
}
```

### 2. å†…å­˜ç®¡ç†æœ€ä½³å®è·µ

#### å†…å­˜åˆ†é…ç­–ç•¥
```c
// æ¨èä½¿ç”¨åç¨‹ä¸“ç”¨çš„å†…å­˜åˆ†é…
void *ptr = EK_CORO_MALLOC(size);
EK_CORO_FREE(ptr);

// è€Œä¸æ˜¯ä½¿ç”¨å…¨å±€å†…å­˜åˆ†é…
void *ptr = EK_MALLOC(size);
EK_FREE(ptr);
```

#### é™æ€ vs åŠ¨æ€åˆ›å»º
```c
// å¯¹äºå…³é”®ä»»åŠ¡ï¼Œæ¨èä½¿ç”¨é™æ€åˆ›å»º
static EK_CoroTCB_t critical_tcb;
static uint32_t critical_stack[256];
EK_CoroStaticHandler_t critical_task = EK_pCoroCreateStatic(
    &critical_tcb, CriticalTask, NULL, 1, critical_stack, sizeof(critical_stack)
);

// å¯¹äºæ™®é€šä»»åŠ¡ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€åˆ›å»º
EK_CoroHandler_t normal_task = EK_pCoroCreate(NormalTask, NULL, 2, 256);
```

### 3. æ¶ˆæ¯é˜Ÿåˆ—ä½¿ç”¨æŠ€å·§

#### æ¶ˆæ¯ç»“æ„è®¾è®¡
```c
typedef struct {
    uint32_t msg_id;        // æ¶ˆæ¯ID
    uint32_t timestamp;     // æ—¶é—´æˆ³
    uint8_t data[32];       // æ•°æ®
} TaskMessage;

// åˆ›å»ºé€‚å½“å¤§å°çš„æ¶ˆæ¯é˜Ÿåˆ—
EK_CoroMsgHanler_t queue = EK_pMsgCreate(sizeof(TaskMessage), 10);
```

#### è¶…æ—¶å¤„ç†
```c
// å»ºè®®ä½¿ç”¨è¶…æ—¶è€Œéæ— é™ç­‰å¾…
EK_Result_t result = EK_rMsgReceive(queue, &msg, 100);
if (result == EK_OK) {
    // å¤„ç†æ¶ˆæ¯
} else if (result == EK_TIMEOUT) {
    // è¶…æ—¶å¤„ç†
}
```

### 4. é”™è¯¯å¤„ç†å’Œè°ƒè¯•

#### é”™è¯¯å¤„ç†æ¨¡å¼
```c
// å§‹ç»ˆæ£€æŸ¥è¿”å›å€¼
EK_Result_t result = EK_rCoroCreate(func, arg, priority, stack_size);
if (result != EK_OK) {
    // é”™è¯¯å¤„ç†
    Error_Handler();
}
```

#### è°ƒè¯•æŠ€å·§
```c
// å¯ç”¨æ ˆæº¢å‡ºæ£€æµ‹è¿›è¡Œè°ƒè¯•
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// å®šæœŸæ£€æŸ¥æ ˆä½¿ç”¨æƒ…å†µ
EK_Size_t water_mark = EK_uCoroGetHighWaterMark(task_handle);
if (water_mark < 32) {
    // æ ˆç©ºé—´ä¸è¶³ï¼Œéœ€è¦è°ƒæ•´
    Warning_Handler();
}
```

---

## ğŸ› å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### 1. ç³»ç»Ÿæ— æ³•å¯åŠ¨

**é—®é¢˜**: ç³»ç»Ÿå¯åŠ¨åå´©æºƒæˆ–æ— æ³•è¿›å…¥ä»»åŠ¡

**è§£å†³æ–¹æ¡ˆ**:
1. æ£€æŸ¥å†…å­˜æ± æ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
2. ç¡®è®¤ SysTick å’Œ PendSV ä¸­æ–­æ­£ç¡®é…ç½®
3. éªŒè¯æ ˆå¤§å°æ˜¯å¦è¶³å¤Ÿ
4. æ£€æŸ¥ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®

```c
// æ£€æŸ¥æ¸…å•
void System_Checklist(void) {
    // 1. å†…å­˜æ± åˆå§‹åŒ–
    if (!EK_bMemPool_Init()) {
        Error_Handler("Memory pool init failed");
    }

    // 2. ä¸­æ–­é…ç½®
    NVIC_SetPriority(PendSV_IRQn, 0xFF);
    NVIC_SetPriority(SysTick_IRQn, 0xF0);

    // 3. åç¨‹åˆå§‹åŒ–
    EK_vKernelInit();

    // 4. å¯åŠ¨è°ƒåº¦å™¨
    EK_vKernelStart();
}
```

### 2. ä»»åŠ¡æ ˆæº¢å‡º

**é—®é¢˜**: ä»»åŠ¡è¿è¡Œä¸€æ®µæ—¶é—´åå´©æºƒ

**è§£å†³æ–¹æ¡ˆ**:
1. å¯ç”¨æ ˆæº¢å‡ºæ£€æµ‹
2. å¢åŠ ä»»åŠ¡æ ˆå¤§å°
3. æ£€æŸ¥é€’å½’è°ƒç”¨å’Œå±€éƒ¨å˜é‡ä½¿ç”¨

```c
// å¯ç”¨æ ˆæº¢å‡ºæ£€æµ‹
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// å®šæœŸæ£€æŸ¥æ ˆä½¿ç”¨æƒ…å†µ
void Monitor_StackUsage(void) {
    EK_Size_t usage = EK_uCoroGetHighWaterMark(task);
    if (usage < 32) {
        // æ ˆç©ºé—´ä¸è¶³
        EK_vCoroSuspend(task, &result);
    }
}
```

### 3. å†…å­˜æ³„æ¼

**é—®é¢˜**: ç³»ç»Ÿé•¿æ—¶é—´è¿è¡Œåå†…å­˜ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**:
1. æ£€æŸ¥å†…å­˜åˆ†é…/é‡Šæ”¾é…å¯¹
2. ä½¿ç”¨å†…å­˜æ± ç»Ÿè®¡ä¿¡æ¯
3. é¿å…åœ¨å¾ªç¯ä¸­é¢‘ç¹åˆ†é…å†…å­˜

```c
// å†…å­˜ç›‘æ§
void Monitor_Memory(void) {
    PoolStats_t stats;
    EK_vMemPool_GetStats(&stats);

    if (stats.Pool_FreeBytes < stats.Pool_TotalSize * 0.1) {
        // å†…å­˜ä¸è¶³è­¦å‘Š
        Warning_Handler("Low memory: %d/%d bytes free",
                       stats.Pool_FreeBytes, stats.Pool_TotalSize);
    }
}
```

### 4. æ¶ˆæ¯é˜Ÿåˆ—é˜»å¡

**é—®é¢˜**: ä»»åŠ¡åœ¨æ¶ˆæ¯é˜Ÿåˆ—æ“ä½œä¸­æ­»é”

**è§£å†³æ–¹æ¡ˆ**:
1. ä½¿ç”¨è¶…æ—¶è€Œéæ— é™ç­‰å¾…
2. åˆç†è®¾è®¡æ¶ˆæ¯é˜Ÿåˆ—å¤§å°
3. é¿å…ä¼˜å…ˆçº§åè½¬

```c
// ä½¿ç”¨è¶…æ—¶
EK_Result_t result = EK_rMsgSend(queue, &msg, 100);
if (result == EK_TIMEOUT) {
    // å¤„ç†å‘é€è¶…æ—¶
    Handle_Timeout();
}
```

---

## ğŸ“– å®Œæ•´ç¤ºä¾‹

### å¤šä»»åŠ¡LEDé—ªçƒç¤ºä¾‹

```c
#include "stm32f4xx_hal.h"
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"
#include "EK_Component/EK_Corotinue/Message/EK_CoroMessage.h"
#include "EK_Component/MemPool/EK_MemPool.h"

// LEDä»»åŠ¡æ¶ˆæ¯ç»“æ„
typedef struct {
    uint8_t led_id;
    uint8_t state;
    uint32_t duration;
} LEDMessage;

// å…¨å±€å˜é‡
EK_CoroMsgHanler_t led_msg_queue;

// LEDæ§åˆ¶ä»»åŠ¡
void LED_Control_Task(void *arg) {
    LEDMessage msg;

    while (1) {
        // ç­‰å¾…LEDæ§åˆ¶æ¶ˆæ¯
        EK_Result_t result = EK_rMsgReceive(led_msg_queue, &msg, EK_MAX_DELAY);

        if (result == EK_OK) {
            // æ§åˆ¶LED
            if (msg.state) {
                HAL_GPIO_WritePin(GPIOA, msg.led_id, GPIO_PIN_SET);
            } else {
                HAL_GPIO_WritePin(GPIOA, msg.led_id, GPIO_PIN_RESET);
            }

            // å»¶æ—¶æŒ‡å®šæ—¶é—´
            EK_vCoroDelay(msg.duration);
        }
    }
}

// ä»»åŠ¡1: LED1é—ªçƒ
void LED1_Task(void *arg) {
    LEDMessage msg = {GPIO_PIN_0, 1, 500};

    while (1) {
        msg.state = 1;
        EK_rMsgSend(led_msg_queue, &msg, 100);

        msg.state = 0;
        EK_rMsgSend(led_msg_queue, &msg, 100);
    }
}

// ä»»åŠ¡2: LED2é—ªçƒ
void LED2_Task(void *arg) {
    LEDMessage msg = {GPIO_PIN_1, 1, 1000};

    while (1) {
        msg.state = 1;
        EK_rMsgSend(led_msg_queue, &msg, 100);

        msg.state = 0;
        EK_rMsgSend(led_msg_queue, &msg, 100);
    }
}

// ç›‘æ§ä»»åŠ¡
void Monitor_Task(void *arg) {
    PoolStats_t stats;

    while (1) {
        // è·å–å†…å­˜æ± ç»Ÿè®¡ä¿¡æ¯
        EK_vMemPool_GetStats(&stats);

        // è·å–ä»»åŠ¡æ ˆä½¿ç”¨æƒ…å†µ
        EK_Size_t led_stack = EK_uCoroGetHighWaterMark(LED_Control_Task);

        // ç›‘æ§ä¿¡æ¯å¤„ç†...

        // æ¯ç§’ç›‘æ§ä¸€æ¬¡
        EK_vCoroDelay(1000);
    }
}

int main(void) {
    // HALåˆå§‹åŒ–
    HAL_Init();
    SystemClock_Config();

    // GPIOåˆå§‹åŒ–
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    // å†…å­˜æ± åˆå§‹åŒ–
    EK_bMemPool_Init();

    // åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—
    led_msg_queue = EK_pMsgCreate(sizeof(LEDMessage), 10);

    // åç¨‹å†…æ ¸åˆå§‹åŒ–
    EK_vKernelInit();

    // åˆ›å»ºä»»åŠ¡
    EK_pCoroCreate(LED_Control_Task, NULL, 1, 512);
    EK_pCoroCreate(LED1_Task, NULL, 2, 256);
    EK_pCoroCreate(LED2_Task, NULL, 2, 256);
    EK_pCoroCreate(Monitor_Task, NULL, 3, 256);

    // å¯åŠ¨åç¨‹è°ƒåº¦å™¨
    EK_vKernelStart();

    while (1) {}
}

// SysTickä¸­æ–­å¤„ç†
void SysTick_Handler(void) {
    EK_vTickHandler();
    HAL_IncTick();
}

// PendSVä¸­æ–­å¤„ç†
void PendSV_Handler(void) {
    EK_vPendSVHandler();
}
```

---

## ğŸ“‹ ç§»æ¤æ£€æŸ¥æ¸…å•

### ç¡¬ä»¶å‡†å¤‡
- [ ] ç¡®è®¤ç›®æ ‡MCUä¸ºARM Cortex-Mç³»åˆ—
- [ ] å‡†å¤‡ç›¸åº”çš„HALåº“æˆ–CMSISåº“
- [ ] ç¡®è®¤å†…å­˜èµ„æºå……è¶³

### æ–‡ä»¶å‡†å¤‡
- [ ] åŒ…å« `EK_Common.h`
- [ ] åŒ…å« `EK_Config.h`
- [ ] åŒ…å« `EK_MemPool.h`
- [ ] åŒ…å« `EK_Queue.h`
- [ ] åŒ…å«åç¨‹ç³»ç»Ÿæ‰€æœ‰æ–‡ä»¶

### é…ç½®æ£€æŸ¥
- [ ] ä¿®æ”¹ `EK_CoroConfig.h` ä¸­çš„MCUå¤´æ–‡ä»¶
- [ ] è®¾ç½®ç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡
- [ ] é…ç½®SysTickä¸­æ–­é¢‘ç‡
- [ ] è®¾ç½®ä¼˜å…ˆçº§ç»„æ•°é‡
- [ ] é…ç½®æ ˆæº¢å‡ºæ£€æµ‹é€‰é¡¹

### ä¸­æ–­é…ç½®
- [ ] å®ç°SysTickä¸­æ–­å¤„ç†å‡½æ•°
- [ ] å®ç°PendSVä¸­æ–­å¤„ç†å‡½æ•°
- [ ] è®¾ç½®æ­£ç¡®çš„ä¸­æ–­ä¼˜å…ˆçº§
- [ ] ç¡®ä¿ä¸­æ–­å‘é‡è¡¨æ­£ç¡®é…ç½®

### åˆå§‹åŒ–æ£€æŸ¥
- [ ] åˆå§‹åŒ–å†…å­˜æ± 
- [ ] åˆå§‹åŒ–åç¨‹å†…æ ¸
- [ ] åˆ›å»ºä»»åŠ¡
- [ ] å¯åŠ¨åç¨‹è°ƒåº¦å™¨

### æµ‹è¯•éªŒè¯
- [ ] ç®€å•ä»»åŠ¡è¿è¡Œæµ‹è¯•
- [ ] ä»»åŠ¡åˆ‡æ¢æµ‹è¯•
- [ ] å»¶æ—¶åŠŸèƒ½æµ‹è¯•
- [ ] æ¶ˆæ¯é˜Ÿåˆ—æµ‹è¯•
- [ ] æ ˆæº¢å‡ºæ£€æµ‹æµ‹è¯•
- [ ] å†…å­˜æ³„æ¼æµ‹è¯•

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœæ‚¨åœ¨ç§»æ¤è¿‡ç¨‹ä¸­é‡åˆ°é—®é¢˜ï¼Œè¯·ï¼š

1. æ£€æŸ¥æœ¬æ–‡æ¡£çš„å¸¸è§é—®é¢˜ç« èŠ‚
2. ç¡®è®¤æŒ‰ç…§ç§»æ¤æ£€æŸ¥æ¸…å•å®Œæˆæ‰€æœ‰æ­¥éª¤
3. æŸ¥çœ‹ç¤ºä¾‹ä»£ç ä¸­çš„å®ç°æ–¹å¼
4. æä¾›è¯¦ç»†çš„é—®é¢˜æè¿°å’Œé”™è¯¯ä¿¡æ¯

**ç‰ˆæœ¬å†å²:**
- v1.0 (2025-10-07): åˆå§‹ç‰ˆæœ¬

---

**æ³¨æ„**: æœ¬æ–‡æ¡£åŸºäº EmbeddedKit v1.0 ç‰ˆæœ¬ç¼–å†™ï¼Œè¯·ç¡®ä¿æ‚¨ä½¿ç”¨çš„ç‰ˆæœ¬ä¸æ–‡æ¡£ç‰ˆæœ¬åŒ¹é…ã€‚