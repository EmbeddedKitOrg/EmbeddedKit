# EmbeddedKit 协程系统移植指南

## 📋 概述

EmbeddedKit 协程系统是一个专为 ARM Cortex-M 微控制器设计的轻量级协作式多任务系统。本指南详细介绍了如何将协程系统移植到您的目标平台，包括配置、API 使用和最佳实践。

**版本**: 1.0
**作者**: N1ntyNine99
**更新日期**: 2025-10-07

---

## 🏗️ 系统架构

### 核心组件

```
EK_Corotinue/
├── Kernel/          # 协程内核核心
│   ├── Kernel.h     # 内核数据结构和API定义
│   ├── Kernel.c     # 内核实现
│   └── Heap.c       # 协程专用堆管理
├── Task/            # 任务管理
│   ├── EK_CoroTask.h # 任务操作API
│   └── EK_CoroTask.c # 任务实现
├── Message/         # 消息队列
│   ├── EK_CoroMessage.h # 消息队列API
│   └── EK_CoroMessage.c # 消息队列实现
├── EK_CoroConfig.h  # 协程底层配置
└── Doc/             # 文档目录
    └── 移植指南.md  # 本文档
```

### 系统依赖关系

```
协程系统
    ↓
内存池系统 (MemPool/)
    ↓
数据结构 (DataStruct/)
    ↓
通用定义 (EK_Common.h)
    ↓
系统配置 (EK_Config.h)
```

---

## 🚀 移植步骤

### 第一步：准备基础环境

#### 1.1 包含必要的文件

确保您的项目中包含以下模块：

```c
// 必须包含的核心文件
#include "EK_Component/EK_Common.h"          // 通用定义和类型
#include "EK_Component/EK_Config.h"         // 系统配置
#include "EK_Component/MemPool/EK_MemPool.h" // 内存池管理
#include "EK_Component/DataStruct/Queue/EK_Queue.h" // 队列数据结构 只有要使用消息队列才使用
```

#### 1.2 初始化内存池

协程系统依赖内存池进行动态内存分配：

```c
#include "EK_Component/MemPool/EK_MemPool.h"

// 在系统启动时调用
void System_Init(void) {
    // 初始化内存池
    EK_bMemPool_Init();

    // 其他初始化...
}
```

### 第二步：配置协程系统

#### 2.1 修改 EK_CoroConfig.h

`EK_CoroConfig.h` 是协程系统的底层配置文件，需要根据您的硬件环境进行配置：

```c
/**
 * @warning: 此处必须要包含你的设备的文件头！
 * @example: #include "stm32f4xx_hal.h"
 */
#include "stm32f4xx_hal.h"  // ← 根据您的MCU修改

// 系统时钟频率
#define EK_CORO_SYSTEM_FREQ (SystemCoreClock)

// SysTick中断频率 (Hz)
#define EK_CORO_TICK_RATE_HZ (1000)

// 优先级组数量 (8, 16, 或 32)
#define EK_CORO_PRIORITY_GROUPS (16)

// 栈溢出检测: 0=禁用, 1=方法1, 2=方法2
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// 空闲任务栈大小 (根据FPU使用情况调整)
#define EK_CORO_IDLE_TASK_STACK_SIZE (256)

// 消息队列支持
#define EK_CORO_MESSAGE_QUEUE_ENABLE (1)
```

#### 2.2 在 EK_Config.h 中启用协程

`EK_Config.h` 是主配置文件，控制协程系统的启用和全局参数：

```c
// 启用协程系统
#define EK_CORO_ENABLE (1)

// 系统时钟频率
#define EK_CORO_SYSTEM_FREQ (SystemCoreClock)

// SysTick中断频率
#define EK_CORO_TICK_RATE_HZ (1000)

// 优先级组数目
#define EK_CORO_PRIORITY_GROUPS (16)

// 协程空闲任务栈大小
#define EK_CORO_IDLE_TASK_STACK_SIZE (256)

// 消息队列支持
#define EK_CORO_MESSAGE_QUEUE_ENABLE (1)

// 栈溢出检测方法
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (0)  // 0:禁用 1:方法1 2:方法2
```

### 第三步：配置中断处理

#### 3.1 配置 SysTick 中断

在您的 SysTick 中断处理函数中添加协程的时钟处理：

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"

void SysTick_Handler(void) {
    // 调用协程的时钟处理函数
    EK_vTickHandler();

    // 如果有HAL库，还需要调用HAL的SysTick处理
    // HAL_IncTick();
    // HAL_SYSTICK_IRQHandler();
}
```

> [!NOTE]
>
> 如果您是使用的是STM32的HAL库，建议让HAL库的uwTick的相关移动到其他定时器，在CubeMX中配置即可

#### 3.2 配置 PendSV 中断

PendSV 中断用于协程上下文切换，需要在中断向量表中配置：

```c
// 在中断向量表中添加 PendSV_Handler
void PendSV_Handler(void) {
    // 调用协程的PendSV处理宏
    EK_vPendSVHandler();
}
```

#### 3.3 中断优先级配置

确保 PendSV 和 SysTick 的优先级设置正确：

```c
// 设置中断优先级
void NVIC_Configuration(void) {
    // PendSV 应该设置为最低优先级
    NVIC_SetPriority(PendSV_IRQn, 0xFF);

    // SysTick 优先级应该高于 PendSV
    NVIC_SetPriority(SysTick_IRQn, 0xF0);
}
```

### 第四步：启动协程系统

#### 4.1 初始化协程内核

```c
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"

int main(void) {
    // 硬件初始化
    HAL_Init();
    SystemClock_Config();

    // 初始化协程内核
    EK_vKernelInit(); // 其中会自动初始化内存池

    // 创建协程任务
    EK_pCoroCreate(Task1, NULL, 1, 256);
    EK_pCoroCreate(Task2, NULL, 2, 256);

    // 启动协程调度器
    EK_vKernelStart();

    // 永远不会到达这里
    while (1) {}
}
```

#### 4.2 示例任务函数

```c
// 任务1示例
void Task1(void *arg) {
    while (1) {
        // 任务代码
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_0);

        // 延时 500ms
        EK_vCoroDelay(500);
    }
}

// 任务2示例
void Task2(void *arg) {
    while (1) {
        // 任务代码
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1);

        // 延时 1000ms
        EK_vCoroDelay(1000);
    }
}
```

---

## ⚙️ 配置参数详解

### 系统配置参数

#### EK_CORO_ENABLE
- **类型**: `0` 或 `1`
- **默认值**: `1`
- **作用**: 启用或禁用协程系统
- **说明**: 设为 `0` 时会使用普通的任务调度器

#### EK_CORO_SYSTEM_FREQ
- **类型**: `uint32_t`
- **默认值**: `SystemCoreClock`
- **作用**: 系统时钟频率
- **说明**: 用于计算 SysTick 重载值

#### EK_CORO_TICK_RATE_HZ
- **类型**: `uint32_t`
- **默认值**: `1000`
- **作用**: SysTick 中断频率
- **说明**: 决定系统时间精度，值越大精度越高但开销越大

#### EK_CORO_PRIORITY_GROUPS
- **类型**: `8`, `16`, 或 `32`
- **默认值**: `16`
- **作用**: 优先级组数量
- **说明**:
  - `8`: 使用 uint8_t 位图，8个优先级
  - `16`: 使用 uint16_t 位图，16个优先级
  - `32`: 使用 uint32_t 位图，32个优先级

#### EK_CORO_IDLE_TASK_STACK_SIZE
- **类型**: `EK_Size_t`
- **默认值**: `256` (无FPU) / `512` (有FPU)
- **作用**: 空闲任务的栈大小
- **说明**: 根据是否使用 FPU 自动调整

#### EK_CORO_MESSAGE_QUEUE_ENABLE
- **类型**: `0` 或 `1`
- **默认值**: `1`
- **作用**: 启用或禁用消息队列功能
- **说明**: 禁用可减少代码大小和内存使用

#### EK_CORO_STACK_OVERFLOW_CHECK_ENABLE
- **类型**: `0`, `1`, 或 `2`
- **默认值**: `0`
- **作用**: 栈溢出检测方法
- **说明**:
  - `0`: 禁用栈溢出检测
  - `1`: 方法1（检测栈底填充值）
  - `2`: 方法2（检测栈指针范围）

### 内存池配置

#### MEMPOOL_SIZE
- **类型**: `EK_Size_t`
- **默认值**: `10240` (10KB)
- **作用**: 内存池总大小
- **说明**: 根据系统内存资源调整

#### MEMPOOL_ALIGNMENT
- **类型**: `EK_Size_t`
- **默认值**: `8`
- **作用**: 内存对齐大小
- **说明**: 必须是2的幂次，通常为4或8字节

---

## 📚 API 使用指南

### 任务管理 API

#### 创建任务

```c
// 动态创建任务
EK_CoroHandler_t task1 = EK_pCoroCreate(
    TaskFunction,    // 任务函数
    arg,             // 任务参数
    priority,        // 优先级 (数值越小优先级越高)
    stack_size       // 栈大小
);

// 静态创建任务
EK_CoroTCB_t tcb;
uint32_t stack[256];
EK_CoroStaticHandler_t task2 = EK_pCoroCreateStatic(
    &tcb,            // 静态TCB
    TaskFunction,    // 任务函数
    arg,             // 任务参数
    priority,        // 优先级
    stack,           // 静态栈
    sizeof(stack)    // 栈大小
);
```

#### 任务控制

```c
// 挂起任务
EK_vCoroSuspend(task_handle, &result);

// 恢复任务
EK_vCoroResume(task_handle, &result);

// 删除任务
EK_vCoroDelete(task_handle, &result);

// 主动让出CPU
EK_vCoroYield();
```

#### 延时操作

```c
// 相对延时
EK_vCoroDelay(100);  // 延时100个tick

// 绝对延时
EK_vCoroDelayUntil(wake_time);  // 延时到指定时间点

// 唤醒任务
EK_rCoroWakeup(task_handle);
```

#### 任务信息查询

```c
// 获取任务栈大小
EK_Size_t stack_size = EK_uCoroGetStack(task_handle);

// 获取任务栈高水位标记
EK_Size_t high_water = EK_uCoroGetHighWaterMark(task_handle);

// 设置任务优先级
EK_vCoroSetPriority(task_handle, new_priority, &result);
```

### 消息队列 API

#### 创建消息队列

```c
// 动态创建消息队列
EK_CoroMsgHanler_t msg_queue = EK_pMsgCreate(
    item_size,      // 每个消息的大小
    item_amount     // 消息数量
);

// 静态创建消息队列
EK_CoroMsg_t msg_struct;
uint8_t msg_buffer[10 * sizeof(MyMessage)];
EK_CoroMsgStaticHanler_t static_queue = EK_pMsgCreateStatic(
    &msg_struct,    // 静态消息队列结构
    msg_buffer,     // 消息缓冲区
    sizeof(MyMessage), // 消息大小
    10              // 消息数量
);
```

#### 消息发送和接收

```c
// 发送消息 (阻塞)
EK_Result_t result = EK_rMsgSend(
    msg_queue,      // 消息队列句柄
    &my_message,    // 要发送的消息
    timeout         // 超时时间
);

// 接收消息 (阻塞)
EK_Result_t result = EK_rMsgReceive(
    msg_queue,      // 消息队列句柄
    &received_msg,  // 接收缓冲区
    timeout         // 超时时间
);
```

#### 消息队列管理

```c
// 删除消息队列
EK_Result_t result = EK_rMsgDelete(msg_queue);
```

---

## 🔧 最佳实践

### 1. 任务设计原则

#### 任务优先级分配
- 数值越小，优先级越高
- 建议将关键任务设置为高优先级
- 避免过多任务使用相同优先级

#### 栈大小配置
```c
// 根据任务复杂度配置栈大小
#define TASK_STACK_MIN    128   // 简单任务
#define TASK_STACK_MID    256   // 中等复杂度任务
#define TASK_STACK_MAX    512   // 复杂任务
#define TASK_STACK_FPU    1024  // 使用FPU的复杂任务
```

#### 任务函数结构
```c
void TaskFunction(void *arg) {
    // 任务初始化代码
    Task_Init();

    while (1) {
        // 任务主循环
        Task_Process();

        // 适当的延时或让出CPU
        EK_vCoroDelay(10);
    }
}
```

### 2. 内存管理最佳实践

#### 内存分配策略
```c
// 推荐使用协程专用的内存分配
void *ptr = EK_CORO_MALLOC(size);
EK_CORO_FREE(ptr);

// 而不是使用全局内存分配
void *ptr = EK_MALLOC(size);
EK_FREE(ptr);
```

#### 静态 vs 动态创建
```c
// 对于关键任务，推荐使用静态创建
static EK_CoroTCB_t critical_tcb;
static uint32_t critical_stack[256];
EK_CoroStaticHandler_t critical_task = EK_pCoroCreateStatic(
    &critical_tcb, CriticalTask, NULL, 1, critical_stack, sizeof(critical_stack)
);

// 对于普通任务，可以使用动态创建
EK_CoroHandler_t normal_task = EK_pCoroCreate(NormalTask, NULL, 2, 256);
```

### 3. 消息队列使用技巧

#### 消息结构设计
```c
typedef struct {
    uint32_t msg_id;        // 消息ID
    uint32_t timestamp;     // 时间戳
    uint8_t data[32];       // 数据
} TaskMessage;

// 创建适当大小的消息队列
EK_CoroMsgHanler_t queue = EK_pMsgCreate(sizeof(TaskMessage), 10);
```

#### 超时处理
```c
// 建议使用超时而非无限等待
EK_Result_t result = EK_rMsgReceive(queue, &msg, 100);
if (result == EK_OK) {
    // 处理消息
} else if (result == EK_TIMEOUT) {
    // 超时处理
}
```

### 4. 错误处理和调试

#### 错误处理模式
```c
// 始终检查返回值
EK_Result_t result = EK_rCoroCreate(func, arg, priority, stack_size);
if (result != EK_OK) {
    // 错误处理
    Error_Handler();
}
```

#### 调试技巧
```c
// 启用栈溢出检测进行调试
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// 定期检查栈使用情况
EK_Size_t water_mark = EK_uCoroGetHighWaterMark(task_handle);
if (water_mark < 32) {
    // 栈空间不足，需要调整
    Warning_Handler();
}
```

---

## 🐛 常见问题和解决方案

### 1. 系统无法启动

**问题**: 系统启动后崩溃或无法进入任务

**解决方案**:
1. 检查内存池是否正确初始化
2. 确认 SysTick 和 PendSV 中断正确配置
3. 验证栈大小是否足够
4. 检查中断优先级设置

```c
// 检查清单
void System_Checklist(void) {
    // 1. 内存池初始化
    if (!EK_bMemPool_Init()) {
        Error_Handler("Memory pool init failed");
    }

    // 2. 中断配置
    NVIC_SetPriority(PendSV_IRQn, 0xFF);
    NVIC_SetPriority(SysTick_IRQn, 0xF0);

    // 3. 协程初始化
    EK_vKernelInit();

    // 4. 启动调度器
    EK_vKernelStart();
}
```

### 2. 任务栈溢出

**问题**: 任务运行一段时间后崩溃

**解决方案**:
1. 启用栈溢出检测
2. 增加任务栈大小
3. 检查递归调用和局部变量使用

```c
// 启用栈溢出检测
#define EK_CORO_STACK_OVERFLOW_CHECK_ENABLE (1)

// 定期检查栈使用情况
void Monitor_StackUsage(void) {
    EK_Size_t usage = EK_uCoroGetHighWaterMark(task);
    if (usage < 32) {
        // 栈空间不足
        EK_vCoroSuspend(task, &result);
    }
}
```

### 3. 内存泄漏

**问题**: 系统长时间运行后内存不足

**解决方案**:
1. 检查内存分配/释放配对
2. 使用内存池统计信息
3. 避免在循环中频繁分配内存

```c
// 内存监控
void Monitor_Memory(void) {
    PoolStats_t stats;
    EK_vMemPool_GetStats(&stats);

    if (stats.Pool_FreeBytes < stats.Pool_TotalSize * 0.1) {
        // 内存不足警告
        Warning_Handler("Low memory: %d/%d bytes free",
                       stats.Pool_FreeBytes, stats.Pool_TotalSize);
    }
}
```

### 4. 消息队列阻塞

**问题**: 任务在消息队列操作中死锁

**解决方案**:
1. 使用超时而非无限等待
2. 合理设计消息队列大小
3. 避免优先级反转

```c
// 使用超时
EK_Result_t result = EK_rMsgSend(queue, &msg, 100);
if (result == EK_TIMEOUT) {
    // 处理发送超时
    Handle_Timeout();
}
```

---

## 📖 完整示例

### 多任务LED闪烁示例

```c
#include "stm32f4xx_hal.h"
#include "EK_Component/EK_Corotinue/Kernel/Kernel.h"
#include "EK_Component/EK_Corotinue/Task/EK_CoroTask.h"
#include "EK_Component/EK_Corotinue/Message/EK_CoroMessage.h"
#include "EK_Component/MemPool/EK_MemPool.h"

// LED任务消息结构
typedef struct {
    uint8_t led_id;
    uint8_t state;
    uint32_t duration;
} LEDMessage;

// 全局变量
EK_CoroMsgHanler_t led_msg_queue;

// LED控制任务
void LED_Control_Task(void *arg) {
    LEDMessage msg;

    while (1) {
        // 等待LED控制消息
        EK_Result_t result = EK_rMsgReceive(led_msg_queue, &msg, EK_MAX_DELAY);

        if (result == EK_OK) {
            // 控制LED
            if (msg.state) {
                HAL_GPIO_WritePin(GPIOA, msg.led_id, GPIO_PIN_SET);
            } else {
                HAL_GPIO_WritePin(GPIOA, msg.led_id, GPIO_PIN_RESET);
            }

            // 延时指定时间
            EK_vCoroDelay(msg.duration);
        }
    }
}

// 任务1: LED1闪烁
void LED1_Task(void *arg) {
    LEDMessage msg = {GPIO_PIN_0, 1, 500};

    while (1) {
        msg.state = 1;
        EK_rMsgSend(led_msg_queue, &msg, 100);

        msg.state = 0;
        EK_rMsgSend(led_msg_queue, &msg, 100);
    }
}

// 任务2: LED2闪烁
void LED2_Task(void *arg) {
    LEDMessage msg = {GPIO_PIN_1, 1, 1000};

    while (1) {
        msg.state = 1;
        EK_rMsgSend(led_msg_queue, &msg, 100);

        msg.state = 0;
        EK_rMsgSend(led_msg_queue, &msg, 100);
    }
}

// 监控任务
void Monitor_Task(void *arg) {
    PoolStats_t stats;

    while (1) {
        // 获取内存池统计信息
        EK_vMemPool_GetStats(&stats);

        // 获取任务栈使用情况
        EK_Size_t led_stack = EK_uCoroGetHighWaterMark(LED_Control_Task);

        // 监控信息处理...

        // 每秒监控一次
        EK_vCoroDelay(1000);
    }
}

int main(void) {
    // HAL初始化
    HAL_Init();
    SystemClock_Config();

    // GPIO初始化
    __HAL_RCC_GPIOA_CLK_ENABLE();
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    // 内存池初始化
    EK_bMemPool_Init();

    // 创建消息队列
    led_msg_queue = EK_pMsgCreate(sizeof(LEDMessage), 10);

    // 协程内核初始化
    EK_vKernelInit();

    // 创建任务
    EK_pCoroCreate(LED_Control_Task, NULL, 1, 512);
    EK_pCoroCreate(LED1_Task, NULL, 2, 256);
    EK_pCoroCreate(LED2_Task, NULL, 2, 256);
    EK_pCoroCreate(Monitor_Task, NULL, 3, 256);

    // 启动协程调度器
    EK_vKernelStart();

    while (1) {}
}

// SysTick中断处理
void SysTick_Handler(void) {
    EK_vTickHandler();
    HAL_IncTick();
}

// PendSV中断处理
void PendSV_Handler(void) {
    EK_vPendSVHandler();
}
```

---

## 📋 移植检查清单

### 硬件准备
- [ ] 确认目标MCU为ARM Cortex-M系列
- [ ] 准备相应的HAL库或CMSIS库
- [ ] 确认内存资源充足

### 文件准备
- [ ] 包含 `EK_Common.h`
- [ ] 包含 `EK_Config.h`
- [ ] 包含 `EK_MemPool.h`
- [ ] 包含 `EK_Queue.h`
- [ ] 包含协程系统所有文件

### 配置检查
- [ ] 修改 `EK_CoroConfig.h` 中的MCU头文件
- [ ] 设置系统时钟频率
- [ ] 配置SysTick中断频率
- [ ] 设置优先级组数量
- [ ] 配置栈溢出检测选项

### 中断配置
- [ ] 实现SysTick中断处理函数
- [ ] 实现PendSV中断处理函数
- [ ] 设置正确的中断优先级
- [ ] 确保中断向量表正确配置

### 初始化检查
- [ ] 初始化内存池
- [ ] 初始化协程内核
- [ ] 创建任务
- [ ] 启动协程调度器

### 测试验证
- [ ] 简单任务运行测试
- [ ] 任务切换测试
- [ ] 延时功能测试
- [ ] 消息队列测试
- [ ] 栈溢出检测测试
- [ ] 内存泄漏测试

---

## 📞 技术支持

如果您在移植过程中遇到问题，请：

1. 检查本文档的常见问题章节
2. 确认按照移植检查清单完成所有步骤
3. 查看示例代码中的实现方式
4. 提供详细的问题描述和错误信息

**版本历史:**
- v1.0 (2025-10-07): 初始版本

---

**注意**: 本文档基于 EmbeddedKit v1.0 版本编写，请确保您使用的版本与文档版本匹配。